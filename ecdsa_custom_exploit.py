# Elliptic Curve Parameters (secp256k1 - Bitcoin Standard)
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F  # Prime field
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  # Order of the group
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240  # Generator x
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337424483  # Generator y

def modular_inverse(a, n):
    """Compute the modular inverse of a modulo n."""
    return pow(a, -1, n)

def derive_private_key(r1, s1, m1, r2, s2, m2):
    """
    Derive the private key using R/S vulnerability and your formulas.
    """
    if r1 != r2:
        raise ValueError("R values must be the same for this vulnerability to apply!")

    # Step 1: Calculate nonce (k) using provided formula
    k = ((m1 - m2) * modular_inverse(s1 - s2, n)) % n
    print(f"Derived Nonce (k): {k}")

    # Step 2: Compute 't = Gk' (X-coordinate of G * k)
    t_x = (Gx * k) % p  # Simplified for demonstration

    # Step 3: Calculate private key using formula
    x = (((s1 * k) - m1) * modular_inverse(r1, n)) % n
    print(f"Derived Private Key (x): {x}")
    
    # Step 4: Verify private key by regenerating public key (P = xG)
    public_key_x = (Gx * x) % p
    print(f"Regenerated Public Key X-Coordinate (P = xG): {public_key_x}")

    return x

# Example Usage
if __name__ == "__main__":
    print("=== Exploit R/S Vulnerability with Your Logic ===")

    # Input signatures and messages
    r1 = int(input("Enter r1 (shared r value): "))
    s1 = int(input("Enter s1: "))
    m1 = int(input("Enter m1 (hashed message 1 as integer): "))

    r2 = int(input("Enter r2 (shared r value): "))
    s2 = int(input("Enter s2: "))
    m2 = int(input("Enter m2 (hashed message 2 as integer): "))

    # Derive private key
    try:
        private_key = derive_private_key(r1, s1, m1, r2, s2, m2)
        print(f"\nFinal Derived Private Key (x): {private_key}")
    except ValueError as e:
        print(f"Error: {e}")
